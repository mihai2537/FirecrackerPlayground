O noua abordare, sper sa fie mai buna ca Strategy_1_3.

Acum voi copia din memoria guest-ului direct intr-un mbuf.
Respectiv voi scrie din mbuf direct in memoria guest-ului, evitand astfel
orice intermediar.

Va mai fi nevoie sa pastrez al doilea thread pentru a verifica daca am
primit pachete de la primary, si daca am primit voi notifica net device-ul
cum am facut si pana acum.

Structura Net va contine acum DpdkClient
---------------------------------------------------------------------------

atentie la do_write_frame_to_guest, am mentionat acolo un warning.

S-ar putea sa fie o problema cu al doilea thread, nu stiu ce se intampla daca dau
mai multe semnale decat e nevoie.

De asemenea, nu stiu daca merge sa folosesc DPDK in paralel pe cele doua threaduri.
Nu prea sunt sincronizate, dar verific doar daca ring-ul e gol si daca nu e gol ii dau un semnal.
In cel mai rau caz dau doar niste semnale in plus, dar eventfd-ul este level triggered deci n-ar trb sa fie probleme.

Cazul RX:
Problema 2 este ca trebuie sa pastrez mbuf-ul in Net device,
pentru ca scrierea in memorie se face in urmatoarea functie apelata, daca nu e vreo eroare.

Ori pastrez mbuf-ul, ori il copiez mereu in alt array si folosesc array-ul ala pt scriere.
--------------------------------------------------------------------------------

Am terminat implementarea si pt TX si pt RX
La RX copiez din mbuf in rx_buf_frame momentan, a fost mai rapid de implementat

Din motive inimaginabile, aceasta strategie are un throughput putin mai mic decat celelalte.
Pros: Nu mai sunt atat de multe pachete pierdute, aproape niciunul.
Nu imi dau seama un e bottleneck-ul.

Idei:

sleep in secondary thread dupa ce da un semnal.
verificat mbuf->next atunci cand primeste un pachet, poate leaga el pachetele ca nebunul.
